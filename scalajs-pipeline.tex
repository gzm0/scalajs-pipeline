\documentclass{beamer}

\usepackage[utf8]{inputenc}

\usepackage{alltt}
\usepackage{listings}
\usepackage{xcolor}

\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}

\lstdefinelanguage{javascript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
%  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
%  commentstyle=\color{purple}\ttfamily,
%  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}


%\usepackage{amssymb}
%\usepackage[overlay,absolute]{textpos}
%\usepackage[normalem]{ulem}

\usepackage{tikz}
\usepackage{tkz-berge}

%% Colors for source highlighting
\definecolor{scKW}  {HTML}{AA37F2}
\definecolor{scFct} {HTML}{1010FF}
\definecolor{scType}{HTML}{228B22}
\definecolor{scVar} {HTML}{A45936}
\definecolor{scComm}{HTML}{B32525}
\definecolor{scObj} {HTML}{008D92}
\definecolor{scStr} {HTML}{952952}

\lstset{
language=scala,
basicstyle=\small\ttfamily,
columns=flexible,
%texcsstyle=*\bf\color{blue},
%numbers=left,
%breaklines=true,
keywordstyle=\color{scKW},
stringstyle=\color{scStr},
showstringspaces=false,
commentstyle=\color{scComm},
%otherkeywords={$},
%frame=leftline,
%backgroundcolor=\color{lightgrey},
%escapeinside=||
}


%% Define _s_cala commands
\newcommand{\sK}[1]{{\color{scKW} #1}}
\newcommand{\sF}[1]{{\color{scFct} #1}}
\newcommand{\sV}[1]{{\color{scVar} #1}}
\newcommand{\sT}[1]{{\color{scType} #1}}
\newcommand{\sC}[1]{{\color{scComm} #1}}
\newcommand{\sO}[1]{{\color{scObj} #1}}
\newcommand{\sS}[1]{{\color{scStr} #1}}
\newcommand{\sH}[1]{{\color{white} #1}}
\newcommand{\sN}[1]{{\color{black} #1}}

%% Define overlay aware commands
%%\newcommand<>{\strike}[1]{\alt#2{\sout{#1}}{#1}}
\newcommand<>{\alertDraw}{\alt#1{\draw[draw=red]}{\draw}}

%%% File icons
\newcommand{\scalaFile}{\includegraphics{icons/files/scala}}
\newcommand{\scalaFiles}[1][1]{\includegraphics[scale=#1]{icons/files/scala_}}
\newcommand{\jsFile}[1][1]{\includegraphics[scale=#1]{icons/files/js}}
\newcommand{\classFiles}{\includegraphics{icons/files/class_}}
\newcommand{\sjsirFiles}{\includegraphics{icons/files/sjsir_}}
\newcommand{\sjsirclassFiles}{\includegraphics{icons/files/sjsir_class_}}

\newcommand{\packageIcon}{\includegraphics{icons/files/package}}

%%% Component icons
\newcommand{\scalajsc}{\includegraphics{icons/components/scalajsc}}
\newcommand{\scalajsld}[1][1]{\includegraphics[scale=#1]{icons/components/scalajsld}}
\newcommand{\scalac}{\includegraphics{icons/components/scalac}}
\newcommand{\javaVM}{\includegraphics{icons/components/jvm}}

\setbeamercovered{transparent}
\setbeamertemplate{navigation symbols}

% Frame number on page
\setbeamertemplate{footline}{\makebox[0.98\paperwidth][r]{\large \raisebox{1.2ex}{\insertframenumber}}}

\setcounter{tocdepth}{1}

\title{The Scala.js Compilation Pipeline}
\author{Tobias Schlatter}
\date{August 15, 2015}

\begin{document}

\begin{frame}[label=simplepipeline]
  \begin{center}
    \visible<2>{\Large The Scala.js Compilation Pipeline}

    \vspace{1cm}

    \begin{tikzpicture}[->,thick]
      \node (scala) at (0,0) {\scalaFiles[1.2]};
      \node (js) at (8,0) {\jsFile[1.2]};
      \node (scalajs) at (4,0) {\scalajsld[1.5]};

      \draw (scala) -- (scalajs);
      \draw (scalajs) -- (js);
    \end{tikzpicture}

    \vspace{1cm}

    \visible<2>{\Large Tobias Schlatter -- \texttt{@gzm0}}
  \end{center}
\end{frame}

\section{A View From Above}

\begin{frame}
  \frametitle{Scala JVM Pipeline}

  \begin{center}
    \begin{tikzpicture}[->,thick]
      \useasboundingbox (0,0) rectangle (10,6);

      % Top pipeline
      \node[label=below:app.scala] (scala1) at (0,4.5) {\scalaFiles};
      \node (scalac1) at (2.5,4.5) {\scalac};
      \node[label=below:app.\alt<2->{jar}{class}] (class1) at (5.5,4.5) {\classFiles};
      \node<2-> at (5,5.2) {\packageIcon};

      \draw (scala1) -- (scalac1);
      \draw (scalac1) -- (class1);

      % Bottom pipeline
      \node<3->[label=below:lib.scala] (scala2) at (0,0) {\scalaFiles};
      \node<3-> (scalac2) at (2.5,0) {\scalac};
      \node<3->[label=below:lib.jar] (class2) at (5.5,0) {\classFiles};
      \node<3-> (jar2) at (5, .6) {\packageIcon};

      \draw<3-> (scala2) -- (scalac2);
      \draw<3-> (scalac2) -- (class2);

      % JVM and inputs
      \node (jvm) at (9,2.25) {\javaVM};

      \draw (class1) -- (jvm);
      \draw<3-> (class2) -- (jvm);

      % Compilation symbols
      \draw<4-> (jar2) -- (scalac1);
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}[label=scalajspipeline]
  \frametitle{Scala.js Pipeline}

  \begin{center}
    \begin{tikzpicture}[->,thick]
      \useasboundingbox (0,0) rectangle (10,6);

      % Top pipeline
      \node[label=below:app.scala] (scala1) at (0,4.5) {\scalaFiles};
      \node (scalajsc1) at (2.5,4.5) {\scalajsc};
      \node<-3>[label=below:app.sjsir] (sjsir1) at (5.5,4.5) {\sjsirFiles};
      \node<2-3>[label=app.class] (class1) at (5.5,5.9) {\classFiles};
      \node<4>[label=below:app.jar] (jar1) at (5.5,4.5) {\sjsirclassFiles};
      \node<4> at (5,5.2) {\packageIcon};

      \draw (scala1) -- (scalajsc1);
      \draw<-3> (scalajsc1) -- (sjsir1);
      \draw<2-3> (scalajsc1) -- (class1);
      \draw<4> (scalajsc1) -- (jar1);

      % Bottom pipeline
      \node[label=below:lib.scala] (scala2) at (0,0) {\scalaFiles};
      \node (scalajsc2) at (2.5,0) {\scalajsc};
      \node<-3>[label=below:lib.sjsir] (sjsir2) at (5.5,0) {\sjsirFiles};
      \node<2-3>[label=lib.class] (class2) at (5.5,1.4) {\classFiles};
      \node<4>[label=below:lib.jar] (jar2) at (5.5,0) {\sjsirclassFiles};
      \node<4> (p2) at (5,.6) {\packageIcon};

      \draw (scala2) -- (scalajsc2);
      \draw<-3> (scalajsc2) -- (sjsir2);
      \draw<2-3> (scalajsc2) -- (class2);
      \draw<4> (scalajsc2) -- (jar2);

      % Linker and JS file
      \node (scalajsld) at (9,2.25) {\scalajsld};
      \node (js) at (9,0) {\jsFile};

      \draw<-3> (sjsir1) -- (scalajsld);
      \draw<4> (jar1) -- (scalajsld);

      \draw<-3> (sjsir2) -- (scalajsld);
      \draw<4> (jar2) -- (scalajsld);

      \draw (scalajsld) -- (js);

      % Compilation symbols
      \draw<3> (class2) -- (scalajsc1);
      \draw<4> (p2) -- (scalajsc1);
    \end{tikzpicture}
  \end{center}
\end{frame}

\section{Scala.js Compiler}

\begin{frame}
  \frametitle{Phases of the Scala.js Compiler}

  \begin{columns}[t]
    \column{.5\textwidth}
    \begin{alltt}
      parser\\
      namer\\
      packageobjects\\
      typer\\
      \alert<2>{jsinterop\\}
      patmat\\
      superaccessors\\
      extmethods\\
      pickler\\
      refchecks\\
      uncurry\\
      tailcalls\\
      specialize\\
    \end{alltt}

    \column{.5\textwidth}
    \begin{alltt}
      explicitouter\\
      erasure\\
      posterasure\\
      lazyvals\\
      lambdalift\\
      constructors\\
      flatten\\
      mixin\\
      \alert<2>{jscode\\}
      cleanup\\
      delambdafy\\
      icode\\
      jvm\\
      terminal
    \end{alltt}
  \end{columns}
\end{frame}

\begin{frame}<-2>[label=scalajsc]
  %% Used in multiple spots
  %% Overlays 1 - 2 used here
  %% Overlays 3 - 7 highlights of individual arrows

  \frametitle{Phases of the Scala.js Compiler}

  \begin{center}
    \begin{tikzpicture}[->,thick,
      phase/.style={
        draw,
        rectangle, rounded corners = 9pt,
        text width=2cm,
        text depth=.9ex,
        text height=.9em,
        text centered}
      ]
      \useasboundingbox (0,-1) rectangle (8,4);

      \node[label=below:app.scala] (scala) at (1,4) {\scalaFiles};
      \node[label=below:lib.class] (inclass) at (7,4) {\classFiles};

      \node[phase] (frontend) at (4, 4) {frontend};

      \node[phase] (jsinterop) at (4, 2.5) {\texttt{jsinterop}};
      \node<2-> at (2.9, 2.8) {\scalajsld[0.35]};

      \node[phase] (scalac) at (4, 1) {backend};

      \node[phase] (jscode) at (1, 0) {\texttt{jscode}};
      \node<2-> at (-.1, 0.3) {\scalajsld[0.35]};

      \node[phase] (jvm) at (7, 0) {\texttt{jvm}};

      \node[label=below:app.sjsir] (sjsir) at (1, -1.5) {\sjsirFiles};
      \node[label=below:app.class] (class) at (7, -1.5) {\classFiles};

      \alertDraw<3> (scala) -- (frontend);
      \draw[dashed] (inclass) -- (frontend);
      \alertDraw<4> (frontend) -- (jsinterop);
      \alertDraw<5> (jsinterop) -- (scalac);
      \alertDraw<6> (scalac) -- (jscode);
      \draw (scalac) -- (jvm);
      \alertDraw<7> (jscode) -- (sjsir);
      \draw (jvm) -- (class);
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Scala.js Compiler -- Example}

  \begin{lstlisting}[gobble=4]
    @JSExport
    class MultiAlerter {
      val msgs = new HelloFactory

      @JSExport
      def multiAlert(n: Int) =
        for (i <- 1 to n) dom.alert(msgs.hello(i))
    }

    class HelloFactory {
      def hello(x: Int) = s"Hello World #$x"
      def helloDebug() = "Hello World"
    }
  \end{lstlisting}
  % $ fix syntax highlighting

\end{frame}

\begin{frame}[fragile]
  \frametitle{Scala.js Compiler -- After frontend}

  \begin{lstlisting}[gobble=4]
    @JSExport
    class MultiAlerter {
      val msgs: HelloFactory = new HelloFactory

      @JSExport
      def multiAlert(n: Int): Unit = {
        intWrapper(1).to(n).foreach[Unit] { (i: Int) =>
          dom.alert(msgs.hello(i))
        }
      }
    }

    class HelloFactory {
      def hello(x: Int): String =
        StringContext.apply("Hello World #", "").s(x)

      def helloDebug(): String = "Hello World"
    }
  \end{lstlisting}

\end{frame}

\againframe<3-4>{scalajsc}

\subsection{\texttt{jsinterop} Phase}

\begin{frame}[fragile]
  \frametitle{Scala.js Compiler -- \texttt{jsinterop}}

  \begin{block}{Responsibilities}
    \begin{itemize}
    \item JavaScript Interop Errors
    \item Exports / JavaScript Methods
    \end{itemize}
  \end{block}

  \pause

  \begin{lstlisting}[gobble=4]
    @JSExport
    class MultiAlerter {
      val msgs: HelloFactory = new HelloFactory
      def multiAlert(n: Int): Unit = // snip

      def $js$exported$meth$multiAlert(n: Int): Any = multiAlert(n)
    }

    class HelloFactory // Unchanged
  \end{lstlisting}

\end{frame}

\againframe<5>{scalajsc}

\begin{frame}[fragile]
  \frametitle{Scala.js Compiler -- After backend}

  \begin{lstlisting}[gobble=4]
    @JSExport
    class MultiAlerter {
      val msgs: HelloFactory = _
      def <init>(): MultiAlerter = { msgs = new HelloFactory }

      def multiAlert(n: Int): Unit = {
        RichInt.to$extension0(intWrapper(1), n).foreach[Unit](
          (new <$anon: Function1>(MultiAlerter.this): Function1)));
      }
      def $js$exported$meth$multiAlert(n: Int): Object = // snip
    }

    class HelloFactory {
      def hello(x: Int): String = {
        new StringContext(wrapRefArray(Array{"Hello World #", ""}))
          .s(genericWrapArray(Array{Int.box(x)}));
      }
      def helloDebug(): String = "Hello World"
    }
  \end{lstlisting}

\end{frame}

\subsection{\texttt{jscode} Phase}

\againframe<6>{scalajsc}

\begin{frame}<1-10>[fragile,label=sjsir]
  %% Used in multiple spots
  %% Overlays  1 -  7 explanations
  %% Overlays  8 - 10 Scalajsc responsibilities
  %% Overlays 11 - 13 Scalajsld responsibilities
  \frametitle{Scala.js Compiler Output: The IR}

  \begin{columns}[t]
    \column{.5\textwidth}
    \begin{block}{General}
      \begin{itemize}
      \item<1-> AST form (typed)
      \item<3-|alert@12-13> Expressions only
      \item<5-|alert@8-10> JavaScript operations
      \end{itemize}
    \end{block}

    \begin{block}<7->{Classes / Interfaces}
      \begin{itemize}
      \item Single class inheritance
      \item Multi interface inheritance
      \item<alert@9-10> No Overloading\\
        (instead: name mangling)
      \item<alert@10> JavaScript methods\\
        (aka Exports)
      \end{itemize}
    \end{block}

    \column{.5\textwidth}
    \begin{block}<6->{Types}
      \begin{itemize}
      \item No generics (erasure)
      \item Primitive types (\texttt{int})
      \item<alert@13> Class types (\texttt{foo.Bar})
      \end{itemize}
    \end{block}

    \begin{overprint}
      \onslide<2>
      \begin{lstlisting}[gobble=8]
        val x = "Foo"; x.charAt(1)

        // Abstract Syntax Tree
        Block(
          ValDef("x", Literal("Foo")),
          Apply(
            Select(Ident("x"), "charAt"),
            List(Literal(0))
          )
        )
      \end{lstlisting}

      \onslide<4>
      \begin{lstlisting}[gobble=8]
        val result = {
          val helper = 1 + 2
          helper * 2
        }

        // VS

        val helper = 1 + 2
        val result = helper * 2
      \end{lstlisting}

    \end{overprint}

  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Scala.js Compiler -- \texttt{jscode}}
  \framesubtitle{Calling JavaScript}


  \begin{block}{Scala Source Code}
    \begin{lstlisting}[gobble=6]
      def multiAlert(n: Int) =
        for (i <- 1 to n) dom.alert(msgs.hello(i))
    \end{lstlisting}

    \pause

    \begin{lstlisting}[gobble=6]
      object dom extends js.GlobalScope {
        def alert(message: String): Unit = js.native
      }
    \end{lstlisting}
  \end{block}

  \pause

  \begin{block}{Scala.js IR}
    \begin{lstlisting}[gobble=6]
      def multiAlert__I__V(n: int) {
        // for (i <- 1 to n) {
          <global>["alert"](
            arg$outer.msgs__LHelloFactory().hello__I__T(i));
        // }
      }
    \end{lstlisting}
    % $ fix syntax highlighting
  \end{block}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Scala.js Compiler -- \texttt{jscode}}
  \framesubtitle{Method Exports}

  \begin{block}{Scala Code after \texttt{jsinterop}}
    \begin{lstlisting}[gobble=6]
      def $js$exported$meth$multiAlert(n: Int): Any =
        multiAlert(n)
    \end{lstlisting}
  \end{block}

  \pause

  \begin{block}{Scala.js IR}
    \begin{lstlisting}[gobble=6]
      def "multiAlert"(arg0: any): any = {
        val prep0: int = arg0.asInstanceOf[I];
        this.$$js$exported$meth$multiAlert__I__O(prep0)
      }
    \end{lstlisting}
    % $ fix syntax highlighting
  \end{block}

\end{frame}

\againframe<7>{scalajsc}
\againframe<4>{scalajspipeline}

\section{Scala.js Linker}

\begin{frame}<-2>[label=scalajsld]
  % Overlays are used in later inclusions of this frame

  \frametitle{Phases of the Scala.js Linker}

  \begin{center}
    \begin{tikzpicture}[->,thick,
      phase/.style={
        draw,
        rectangle, rounded corners = 9pt,
        text width=2cm,
        text depth=.9ex,
        text height=.9em,
        text centered}
      ]

      \node (sjsir) at (0, 6) {\sjsirFiles};

      \node[phase] (linker) at (3, 6) {Linker};

      \node[phase,dashed] (irchecker) at (5.5, 5) {IR Checker};

      \node[phase] (optimizer) at (3, 4.5) {Optimizer};
      \node[phase] (refiner) at (3, 3) {Refiner};
      \node[phase] (emitter) at (3, 1.5) {Emitter};

      \node[phase,dashed] (closure) at (3, 0) {Closure};

      \node (fastopt) at (7,1.5) {\jsFile};
      \node (fullopt) at (7,0) {\jsFile[0.6]};

      \draw[dashed] (linker) to [out=-90,in=180,right] (irchecker);
      \alertDraw<2> (sjsir) -- (linker);
      \alertDraw<3> (linker) -- (optimizer);
      \alertDraw<4> (optimizer) -- (refiner);
      \alertDraw<5> (refiner) -- (emitter);
      \alertDraw<6> (emitter) -- node[above] {fastOpt} (fastopt);

      \draw[dashed] (emitter) -- (closure);
      \draw[dashed] (closure) -- node[above] {fullOpt} (fullopt);

    \end{tikzpicture}
  \end{center}

\end{frame}

\subsection{Linker Phase}

\begin{frame}<-7>[fragile]
  % Overlay 8 is a dummy overlay to simulate a command that always greys out

  \frametitle{Scala.js Linker -- Linker Phase}
  \framesubtitle{Alive Code Inclusion}

  % Using semiverbatim because too many overlay interactions
  \begin{semiverbatim}
\uncover<2->{@JSExport}
\uncover<3->{class MultiAlerter \{
  val msgs = new HelloFactory}

  \uncover<5->{@JSExport}
  \uncover<6->{def multiAlert(n: Int) =
    for (i <- 1 to n) dom.alert(msgs.hello(i))}
\uncover<3->{\}}

\uncover<4->{class HelloFactory \{}
  \uncover<7->{def hello(x: Int) = s"Hello World #$x"}
  \uncover<8>{def helloDebug() = "Hello World"}
\uncover<4->{\}}
  \end{semiverbatim}
  % $ fix syntax highlighting

\end{frame}

\againframe<3>{scalajsld}

\begin{frame}[fragile]
  \frametitle{Scala.js Linker -- Optimizer Phase}

  \begin{overprint}
    \onslide<1,3->
    \begin{lstlisting}[gobble=6]
      def multiAlert__I__V(n: int) {
        // for (i <- 1 to n) {
          <global>["alert"](
            arg$outer.msgs__LHelloFactory().hello__I__T(i));
        // }
      }
    \end{lstlisting}
    % $ fix syntax highlighting


    \begin{semiverbatim} \small \uncover<4>{
def multiAlert__I__V(n: int) \{
  var i: int = 0
  while (i <[int] n) \{
    <global>["alert"](this.msgs$1.hello__I__T(i));
    i = i +[int] 1;
  \}
\}}
    \end{semiverbatim}
    % $ fix syntax highlighting

    \onslide<2>
    \begin{lstlisting}[gobble=6]
      def multiAlert__I__V(n: int) {
        mod:sr_RichInt$.to$extension0__I__I__sci_Range$Inclusive(
          mod:s_Predef$.intWrapper__I__I(1), n).foreach$mVc$sp__F1__V(
            new sjsr_AnonFunction1().init___sjs_js_Function1(
            (lambda<this>(arg$outer: LMultiAlerter, i$2: any) = {
              val i: int = i$2.asInstanceOf[I];
              <global>["alert"](
                arg$outer.msgs__LHelloFactory().hello__I__T(i)
              );
              (void 0)
            }
        )))
      }
    \end{lstlisting}
  \end{overprint}

\end{frame}

\againframe<4-5>{scalajsld}

\againframe<11-13>{sjsir}

\subsection{Emitter Phase}

\begin{frame}[fragile]
  \frametitle{Scala.js Linker -- Emitter Phase}
  \framesubtitle{Desugaring}

  \begin{block}{Scala Code\phantom{p}}
    \begin{lstlisting}[gobble=6]
      def norm(a: Int, b: String) = {
        val b2 = { val b0 = b.toInt; b0 * b0 }
        math.sqrt(a * a + b2)
      }
    \end{lstlisting}
  \end{block}

  \pause

  \begin{block}{\alt<5>{}{Pseudo }JavaScript Code}
    \begin{semiverbatim}
\small{}var norm = function(a2, b) \{
  \only<-2>{return }\{
    \only<-3>{var b2 = }\{
      var b0 = parseInt(b, 10)
      \only<4->{var b2 = }b0 * b0;
    \};
    \only<3->{return }Math.sqrt(a * a + b2);
  \};
\}      
    \end{semiverbatim}
  \end{block}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Scala.js Linker -- Emitter Phase}
  \framesubtitle{Class Emission Order}

  \begin{columns}[t]
    \column{.37\textwidth}
    \begin{block}{Scala Code\phantom{p}}
      \begin{lstlisting}[gobble=8]
        class A {
          def a = (new B).b + 1
        }

        class B extends A {
          def b = 1
        }
      \end{lstlisting}
    \end{block}

    \pause

    \column{.53\textwidth}
    \begin{block}{JavaScript Code}
      \begin{lstlisting}[language=javascript,gobble=8]
        var A = function() {};
        A.prototype.a = function() // ...


        var B = function() {};
        B.prototype = new A();
        B.prototype.b = function() // ...
      \end{lstlisting}
    \end{block}
  \end{columns}

  \pause

  \begin{block}{Strategy}
    \begin{itemize}
    \item Definition only depends on superclass definition
    \pause
    \item Order definitions by superclass count
    \end{itemize}
  \end{block}

\end{frame}

\againframe<6>{scalajsld}
\againframe<1>{simplepipeline}

\section*{Things I Shamelessly Omitted}

\begin{frame}
  \frametitle{Things I Shamelessly Omitted}

  \begin{block}{Scala.js IR}
    \begin{itemize}
    \item Hijacked Classes (and string IR type)
    \item Helper types (Undefined, Null, Nothing, NoType, Records)
    \item Array types (\texttt{int[]}, \texttt{A[]})
    \item Labeled Blocks (pattern matches, tailrec methods)
    \item Modules (objects)
    \item Class Nesting
    \end{itemize}
  \end{block}

  \begin{columns}[t]
    \column{.45\textwidth}
    \begin{block}{Compiler}
      \begin{itemize}
      \item \texttt{scala.Enumeration}
      \item Reflective Calls
      \item JavaScript Function literals
      \end{itemize}
    \end{block}

    \column{.45\textwidth}
    \begin{block}{Linker}
      \begin{itemize}
      \item Instance tests for raw JavaScript types
      \item Longs
      \item Output modes
      \end{itemize}
    \end{block}
  \end{columns}

\end{frame}

\end{document}